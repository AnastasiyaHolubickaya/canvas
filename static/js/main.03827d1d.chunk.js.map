{"version":3,"sources":["redux/canvasReducer.tsx","redux/selectors.ts","util/drawLines.ts","components/Canvas.tsx","App.tsx","reportWebVitals.ts","redux/store.ts","index.tsx"],"names":["initialState","canvasState","canvasSize","context","collaps_step","actions","type","canvasReducer","state","action","stateCanvas","size","getCanvasSizeReselect","createSelector","canvas","getContextReselect","getStepReselect","lineSegmentIntersect","currentCrdnt","prevCrdnt","x1","y1","x2","y2","x3","y3","a_dx","a_dy","b_dx","b_dy","s","t","drawDot","mass","forEach","e","moveTo","arc","Math","PI","fillStyle","fill","drawLine","beginPath","lineTo","strokeStyle","stroke","Styledcanvas","styled","Canvas","width","height","paint","dispatch","useDispatch","ref","useRef","useSelector","counter","coordinateCurrentLine","coordinatePaintingLines","coordinateLinesWithStepCollaps","coordinatePointIntersection","useEffect","current","getContext","drawLineCollaps","clearRect","i","length","paintingCollapsLine","requestAnimationFrame","console","log","ctx","getCoordinates","event","pageX","pageY","handleRightClick","preventDefault","push","massXY","xC","yC","concat","findStepCollapsLine","currentMass","masslines","pointIntersect","draw","handleButtonClick","onContextMenu","onClick","handleonClick","onMouseMove","x","y","map","handleMouseMove","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","reducers","combineReducers","composeEnhancers","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","store","createStore","applyMiddleware","thunkMiddleware","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.03827d1d.chunk.js","sourcesContent":["import {InferActionType} from \"./store\";\r\n\r\n\r\nlet initialState = {\r\n    canvasState: false,\r\n    canvasSize: [300, 300],\r\n    context: null as CanvasRenderingContext2D | null,\r\n    collaps_step: 101\r\n};\r\nexport type initialStateType = typeof initialState;\r\n\r\ntype ActionsType = InferActionType<typeof actions>;\r\n\r\n\r\nconst canvasReducer = (state = initialState, action: ActionsType): initialStateType => {\r\n    switch (action.type) {\r\n        case  \"SET_CANVAS_STATE\":\r\n            return {\r\n                ...state,\r\n                canvasState: action.stateCanvas\r\n            };\r\n        case  \"SET_CANVAS_SIZE\":\r\n            return {\r\n                ...state,\r\n                canvasSize: action.size\r\n            };\r\n        case  \"SET_CONTEXT\":\r\n            return {\r\n                ...state,\r\n                context: action.context\r\n            };\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\nexport const actions = {\r\n    setCanvasState: (stateCanvas: boolean) => ({type: \"SET_CANVAS_STATE\", stateCanvas} as const),\r\n    setCanvasSize: (size: Array<number>) => ({type: 'SET_CANVAS_SIZE', size} as const),\r\n    setContext: (context: CanvasRenderingContext2D | null) => ({type: 'SET_CONTEXT', context} as const)\r\n};\r\n\r\n\r\nexport default canvasReducer;","import {createSelector} from \"reselect\";\r\nimport {AppStateType} from \"./store\";\r\n\r\nconst getCanvasSize = (state: AppStateType) => {\r\n    return state.canvas.canvasSize\r\n};\r\nconst getContext = (state: AppStateType) => {\r\n    return state.canvas.context\r\n};\r\nconst getStep = (state: AppStateType) => {\r\n    return state.canvas.collaps_step\r\n};\r\n\r\nexport const getCanvasSizeReselect = createSelector(getCanvasSize, (canvasSize) => {\r\n    return canvasSize;\r\n});\r\nexport const getContextReselect = createSelector(getContext, (context) => {\r\n    return context;\r\n});\r\nexport const getStepReselect = createSelector(getStep,(collaps_step) =>{\r\n    return collaps_step;\r\n});","\r\nimport {\r\n    drawType,\r\n    drawLineType,\r\n    findStepCollapsLineType,\r\n    lineSegmentIntersectType,\r\n    drawDotType, coordinateType\r\n} from \"../redux/types/types\";\r\n\r\n//определяем шаг сворачивании для каждой линии\r\nexport const findStepCollapsLine: findStepCollapsLineType = (massXY, collaps_step) => {\r\n    let mass = [];\r\n    let xC = (massXY[2] - massXY[0]) / 2 / collaps_step;\r\n    mass.push(xC);\r\n    let yC = (massXY[3] - massXY[1]) / 2 / collaps_step;\r\n    mass.push(yC);\r\n    return massXY.concat(mass);\r\n};\r\n\r\n//определяем точку пересечения  линий\r\nconst lineSegmentIntersect: lineSegmentIntersectType = (currentCrdnt, prevCrdnt) => {\r\n    let [x1, y1, x2, y2] = currentCrdnt;\r\n    let [x3, y3, x4, y4] = prevCrdnt;\r\n    let a_dx = x2 - x1;\r\n    let a_dy = y2 - y1;\r\n    let b_dx = x4 - x3;\r\n    let b_dy = y4 - y3;\r\n    let s = (-a_dy * (x1 - x3) + a_dx * (y1 - y3)) / (-b_dx * a_dy + a_dx * b_dy);\r\n    let t = (+b_dx * (y1 - y3) - b_dy * (x1 - x3)) / (-b_dx * a_dy + a_dx * b_dy);\r\n    let x = x1 + t * a_dx;\r\n    let y = y1 + t * a_dy;\r\n    return (s >= 0 && s <= 1 && t >= 0 && t <= 1) ? [x, y] : false;\r\n};\r\n\r\n//рисуем точки\r\nexport const drawDot:drawDotType = (context, mass) => {\r\n    if (context !== null) {\r\n        mass.forEach(e =>  {\r\n            // @ts-ignore\r\n            context.moveTo(e[0], e[1]);\r\n            // @ts-ignore\r\n            context.arc(e[0], e[1], 3, 0, Math.PI * 2, true);//arc(90,65,5,0,Math.PI*2,true)\r\n            context.fillStyle = 'red';\r\n            context.fill();\r\n        }\r\n    )\r\n    }\r\n};\r\n//заполняет массив  точки на пересечении\r\nexport const draw:drawType = (context, currentMass, masslines, pointIntersect) => {\r\n    try {\r\n        let mass:Array<coordinateType>|boolean = [];\r\n        for (let i = 0; i < masslines.length; i++) {\r\n            mass = lineSegmentIntersect(currentMass, masslines[i]);\r\n            if(mass!==false){\r\n                // @ts-ignore\r\n                pointIntersect.push(mass);\r\n            }\r\n        }\r\n    }catch (e) {\r\n        console.log(`'draw' ${e}`);\r\n    }\r\n    return pointIntersect;\r\n};\r\n//рисуем линии\r\nexport const drawLine: drawLineType = (context, mass) => {\r\n    if (context !== null) {\r\n        context.beginPath();\r\n        context.moveTo(mass[0], mass[1]);\r\n        context.lineTo(mass[2], mass[3]);\r\n        context.strokeStyle = 'black';\r\n        context.stroke();\r\n    }\r\n};","import React, {useEffect, useRef} from \"react\";\r\nimport styled from \"styled-components\";\r\nimport {useDispatch, useSelector} from \"react-redux\";\r\nimport {actions} from \"../redux/canvasReducer\";\r\nimport {getContextReselect, getStepReselect} from \"../redux/selectors\";\r\nimport {CanvasPropsType} from \"../redux/types/types\";\r\nimport {draw, drawDot, drawLine, findStepCollapsLine} from \"../util/drawLines\";\r\n\r\n\r\nconst Styledcanvas = styled.canvas`\r\n   margin: 0 auto;\r\n   border: 2px solid red;\r\n`;\r\n\r\n\r\nexport const Canvas: React.FC<CanvasPropsType> = ({width, height}) => {\r\n    //let [isPaint, setIsPaint] = useState(false);\r\n    let paint = false;\r\n    const dispatch = useDispatch();\r\n    const ref = useRef<HTMLCanvasElement>(null);\r\n    const context = useSelector(getContextReselect);\r\n    const collaps_step = useSelector(getStepReselect);\r\n    let counter = 0;\r\n    let coordinateCurrentLine: Array<number> = [];// массив координат текущей линии\r\n    let coordinatePaintingLines: Array<Array<number>> = [];// массив  координат всех нарисованных линий\r\n    let coordinateLinesWithStepCollaps: Array<Array<number>> = [];\r\n    let coordinatePointIntersection: Array<number> = [];// массив точек пересечения линий\r\n\r\n\r\n    useEffect(() => {\r\n        if (!ref.current) {\r\n            return;\r\n        }\r\n        const canvas = ref.current;\r\n        dispatch(actions.setContext(canvas.getContext('2d')));\r\n        //getContext();\r\n    }, [dispatch]);// пустая зависимость означает сделать что-то когда компонента вмонтировалась ( componentDidMount())\r\n\r\n    //очистка массивов\r\n    const clear = () => {\r\n        coordinateCurrentLine = [];\r\n        coordinatePaintingLines = [];\r\n        coordinatePointIntersection = []\r\n    };\r\n\r\n    //воспроизведение  анимации линий\r\n    const drawLineCollaps = () => {\r\n        try {\r\n            if (context !== null)\r\n                context.clearRect(0, 0, width, height);\r\n            for (let i = 0; i <= coordinateLinesWithStepCollaps.length - 1; i++) {\r\n                paintingCollapsLine(context, coordinateLinesWithStepCollaps[i]);\r\n            }\r\n            if (counter < collaps_step - 1) {\r\n                requestAnimationFrame(drawLineCollaps);\r\n                counter++;\r\n            } else {\r\n                counter = 0;\r\n                coordinateLinesWithStepCollaps = [];\r\n            }\r\n        } catch (e) {\r\n            console.log(`'lineCollaps' ${e}`);\r\n        }\r\n    };\r\n    const paintingCollapsLine = (ctx: any, t: any) => {\r\n        ctx.beginPath();\r\n        ctx.moveTo(t[0] + t[4], t[1] + t[5]);\r\n        ctx.lineTo(t[2] - t[4], t[3] - t[5]);\r\n        ctx.stroke();\r\n        t[0] += t[4];\r\n        t[2] -= t[4];\r\n        t[1] += t[5];\r\n        t[3] -= t[5];\r\n    };\r\n\r\n    //захват координат мыши\r\n    const getCoordinates = (event: React.MouseEvent<HTMLCanvasElement>) => {\r\n        let x = event.pageX;\r\n        let y = event.pageY;\r\n        return [x, y]\r\n    };\r\n\r\n    const handleMouseMove = (event: React.MouseEvent<HTMLCanvasElement>) => {\r\n        if (paint) {\r\n            let [x,y] = getCoordinates(event);\r\n            if (context !== null) {\r\n                context.clearRect(0, 0, width, height);\r\n                if (coordinatePaintingLines.length < 1) {\r\n                    coordinateCurrentLine[2] = x;\r\n                    coordinateCurrentLine[3] = y;\r\n                    drawLine(context, coordinateCurrentLine);\r\n                } else {\r\n                    coordinatePaintingLines.map(e => drawLine(context, e));\r\n                    coordinateCurrentLine[2] = x;\r\n                    coordinateCurrentLine[3] = y;\r\n                    drawLine(context, coordinateCurrentLine);\r\n                }\r\n                    drawDot(context,coordinatePointIntersection);\r\n            }\r\n        }\r\n    };\r\n    const handleonClick = (event: React.MouseEvent<HTMLCanvasElement>) => {\r\n        let [x1,y1] = getCoordinates(event);\r\n        coordinateCurrentLine[0] = x1;\r\n        coordinateCurrentLine[1] = y1;\r\n        paint = true;\r\n    };\r\n    const handleRightClick = (event: React.MouseEvent<HTMLCanvasElement>) => {\r\n        event.preventDefault();\r\n        paint = false;\r\n        let [x2,y2] = getCoordinates(event);\r\n        coordinateCurrentLine[2] = x2;\r\n        coordinateCurrentLine[3] = y2;\r\n        coordinatePaintingLines.push(coordinateCurrentLine);\r\n        coordinateLinesWithStepCollaps.push(findStepCollapsLine(coordinateCurrentLine, collaps_step));\r\n        drawLine(context, coordinateCurrentLine);\r\n        draw(context, coordinateCurrentLine, coordinatePaintingLines, coordinatePointIntersection);\r\n        drawDot(context,coordinatePointIntersection);\r\n        coordinateCurrentLine = [];\r\n    };\r\n    const handleButtonClick = (event: React.MouseEvent) => {\r\n        drawLineCollaps();\r\n        clear();\r\n    };\r\n\r\n\r\n    return <>\r\n        <Styledcanvas onContextMenu={event => handleRightClick(event)} onClick={event => handleonClick(event)}\r\n                      onMouseMove={event => handleMouseMove(event)} ref={ref}/>\r\n        <button onClick={event => handleButtonClick(event)}> Collaps Line</button>\r\n    </>\r\n\r\n};\r\n","import React from 'react';\nimport {Canvas} from \"./components/Canvas\";\nimport './App.css';\nimport {useSelector} from \"react-redux\";\nimport {getCanvasSizeReselect} from \"./redux/selectors\";\n\nfunction App() {\n  const [width, height] = useSelector(getCanvasSizeReselect);\n\n  return (\n        <Canvas width={width} height={height}/>\n  )\n}\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import {applyMiddleware, combineReducers, compose, createStore} from \"redux\";\r\nimport canvasReducer from \"./canvasReducer\";\r\nimport thunkMiddleware from \"redux-thunk\";\r\n\r\n\r\nlet reducers = combineReducers(\r\n    {\r\n        canvas: canvasReducer\r\n    }\r\n);\r\ntype RootReduserType = typeof reducers;//типизируем reducers\r\nexport type AppStateType = ReturnType<RootReduserType>;//динамически достаем из функции то, что она возвращает - глобальный state\r\n\r\ntype PropertyTypes<T> = T extends {[key: string]: infer U} ?U : never\r\nexport  type InferActionType<T extends {[key: string]:(...args:any[])=>any}> = ReturnType<PropertyTypes<T>>\r\n\r\n//@ts-ignore\r\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__|| compose;//для подключения к проекту расширения REDUX для google chrom\r\nconst store = createStore(reducers, composeEnhancers(\r\n    applyMiddleware(thunkMiddleware)\r\n));\r\n\r\nexport default store;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport  {Provider} from \"react-redux\";\nimport store from './redux/store';\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}